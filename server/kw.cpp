/***** This file contains automatically generated code ******
**
** The code in this file has been automatically generated by
**
**   mkkeywordhash.c
**
** The code in this file implements a function that determines whether
** or not a given identifier is really an SQL keyword.  The same thing
** might be implemented more directly using a hand-written hash table.
** But by using this automatically generated code, the size of the code
** is substantially reduced.  This is important for embedded applications
** on platforms with limited memory.
*/
/* Hash score: 32 */
static inline int keywordCode(const char *z, int n) {
	/* zText[] encodes 154 bytes of keywords in 98 bytes */
	/*   DESCAPEXPLAINFROMNANALYZEXCLUSIVEXORDERANDBETWEENOTNULLIKEIF       */
	/*   ISNULLIMITPRAGMASCWHEREBYOFFSETSELECT                              */
	static const char zText[97] = {
		'D', 'E', 'S', 'C', 'A', 'P', 'E', 'X', 'P', 'L', 'A', 'I', 'N', 'F',
		'R', 'O', 'M', 'N', 'A', 'N', 'A', 'L', 'Y', 'Z', 'E', 'X', 'C', 'L',
		'U', 'S', 'I', 'V', 'E', 'X', 'O', 'R', 'D', 'E', 'R', 'A', 'N', 'D',
		'B', 'E', 'T', 'W', 'E', 'E', 'N', 'O', 'T', 'N', 'U', 'L', 'L', 'I',
		'K', 'E', 'I', 'F', 'I', 'S', 'N', 'U', 'L', 'L', 'I', 'M', 'I', 'T',
		'P', 'R', 'A', 'G', 'M', 'A', 'S', 'C', 'W', 'H', 'E', 'R', 'E', 'B',
		'Y', 'O', 'F', 'F', 'S', 'E', 'T', 'S', 'E', 'L', 'E', 'C', 'T',
	};
	static const unsigned char aHash[46] = {
		27, 16, 12, 22, 0, 2, 5, 0, 0, 11, 19, 7, 28, 14, 0, 0, 25, 18, 17, 0,
		0, 15, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 13, 8, 6, 24, 0, 0, 0, 9, 26,
		0, 10, 0, 23,
	};
	static const unsigned char aNext[28] = {
		0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 20, 0,
	};
	static const unsigned char aLen[28] = {
		4, 6, 7, 3, 2, 4, 3, 7, 9, 3, 5, 2, 3, 7, 7, 3, 4, 4, 2, 6, 2, 5, 6, 3,
		5, 2, 6, 6,
	};
	static const unsigned short int aOffset[28] = {
		0, 1, 6, 11, 11, 13, 17, 18, 24, 33, 34, 34, 39, 42, 48, 48, 51, 54, 58,
		60, 60, 65, 70, 75, 78, 83, 85, 91,
	};
	static const unsigned char aCode[28] = {
		TK_DESC, TK_ESCAPE, TK_EXPLAIN, TK_INF, TK_IN, TK_FROM, TK_NAN,
		TK_ANALYZE, TK_EXCLUSIVE, TK_XOR, TK_ORDER, TK_OR, TK_AND, TK_BETWEEN,
		TK_NOTNULL, TK_NOT, TK_NULL, TK_LIKE_KW, TK_IF, TK_ISNULL, TK_IS,
		TK_LIMIT, TK_PRAGMA, TK_ASC, TK_WHERE, TK_BY, TK_OFFSET, TK_SELECT,
	};
	int h, i;
	if (n < 2) return TK_ID;
	h = ((charMap(z[0]) * 4) ^ (charMap(z[n - 1]) * 3) ^ n) % 46;
	for (i = ((int)aHash[h]) - 1; i >= 0; i = ((int)aNext[i]) - 1) {
		if (aLen[i] == n && gsStrNICmp(&zText[aOffset[i]], z, n) == 0) {
			testcase(i == 0);  /* DESC */
			testcase(i == 1);  /* ESCAPE */
			testcase(i == 2);  /* EXPLAIN */
			testcase(i == 3);  /* INF */
			testcase(i == 4);  /* IN */
			testcase(i == 5);  /* FROM */
			testcase(i == 6);  /* NAN */
			testcase(i == 7);  /* ANALYZE */
			testcase(i == 8);  /* EXCLUSIVE */
			testcase(i == 9);  /* XOR */
			testcase(i == 10); /* ORDER */
			testcase(i == 11); /* OR */
			testcase(i == 12); /* AND */
			testcase(i == 13); /* BETWEEN */
			testcase(i == 14); /* NOTNULL */
			testcase(i == 15); /* NOT */
			testcase(i == 16); /* NULL */
			testcase(i == 17); /* LIKE */
			testcase(i == 18); /* IF */
			testcase(i == 19); /* ISNULL */
			testcase(i == 20); /* IS */
			testcase(i == 21); /* LIMIT */
			testcase(i == 22); /* PRAGMA */
			testcase(i == 23); /* ASC */
			testcase(i == 24); /* WHERE */
			testcase(i == 25); /* BY */
			testcase(i == 26); /* OFFSET */
			testcase(i == 27); /* SELECT */
			return aCode[i];
		}
	}
	return TK_ID;
}
#define GS_N_KEYWORD 28
